{ Client: 'class Client extends EventEmitter {\n  /**\n   * @param {ClientOptions} [options] Options for the client\n   */\n  constructor(options) {\n    super();\n    this.options = mergeDefault(Constants.DefaultOptions, options);\n    /**\n     * The REST manager of the client\n     * @type {RESTManager}\n     * @private\n     */\n    this.rest = new RESTManager(this);\n    /**\n     * The data manager of the Client\n     * @type {ClientDataManager}\n     * @private\n     */\n    this.dataManager = new ClientDataManager(this);\n    /**\n     * The manager of the Client\n     * @type {ClientManager}\n     * @private\n     */\n    this.manager = new ClientManager(this);\n    /**\n     * The WebSocket Manager of the Client\n     * @type {WebSocketManager}\n     * @private\n     */\n    this.ws = new WebSocketManager(this);\n    /**\n     * The Data Resolver of the Client\n     * @type {ClientDataResolver}\n     * @private\n     */\n    this.resolver = new ClientDataResolver(this);\n    /**\n     * The Action Manager of the Client\n     * @type {ActionsManager}\n     * @private\n     */\n    this.actions = new ActionsManager(this);\n    /**\n     * The Voice Manager of the Client\n     * @type {ClientVoiceManager}\n     * @private\n     */\n    this.voice = new ClientVoiceManager(this);\n    /**\n     * A Collection of the Client\'s stored users\n     * @type {Collection<string, User>}\n     */\n    this.users = new Collection();\n    /**\n     * A Collection of the Client\'s stored guilds\n     * @type {Collection<string, Guild>}\n     */\n    this.guilds = new Collection();\n    /**\n     * A Collection of the Client\'s stored channels\n     * @type {Collection<string, Channel>}\n     */\n    this.channels = new Collection();\n    /**\n     * The authorization token for the logged in user/bot.\n     * @type {?string}\n     */\n    this.token = null;\n    /**\n     * The ClientUser representing the logged in Client\n     * @type {?ClientUser}\n     */\n    this.user = null;\n    /**\n     * The email, if there is one, for the logged in Client\n     * @type {?string}\n     */\n    this.email = null;\n    /**\n     * The password, if there is one, for the logged in Client\n     * @type {?string}\n     */\n    this.password = null;\n    /**\n     * The date at which the Client was regarded as being in the `READY` state.\n     * @type {?Date}\n     */\n    this.readyTime = null;\n    this._intervals = [];\n    this._timeouts = [];\n  }\n\n  /**\n   * Logs the client in. If successful, resolves with the account\'s token. <warn>If you\'re making a bot, it\'s\n   * much better to use a bot account rather than a user account.\n   * Bot accounts have higher rate limits and have access to some features user accounts don\'t have. User bots\n   * that are making a lot of API requests can even be banned.</warn>\n   * @param  {string} emailOrToken The email or token used for the account. If it is an email, a password _must_ be\n   * provided.\n   * @param  {string} [password] The password for the account, only needed if an email was provided.\n   * @returns {Promise<string>}\n   * @example\n   * // log the client in using a token\n   * const token = \'my token\';\n   * client.login(token);\n   * @example\n   * // log the client in using email and password\n   * const email = \'user@email.com\';\n   * const password = \'supersecret123\';\n   * client.login(email, password);\n   */\n  login(emailOrToken, password) {\n    if (password) return this.rest.methods.loginEmailPassword(emailOrToken, password);\n    return this.rest.methods.loginToken(emailOrToken);\n  }\n\n  /**\n   * Destroys the client and logs out.\n   * @returns {Promise}\n   */\n  destroy() {\n    return new Promise((resolve, reject) => {\n      this.manager.destroy().then(() => {\n        this._intervals.map(i => clearInterval(i));\n        this._timeouts.map(t => clearTimeout(t));\n        this.token = null;\n        this.email = null;\n        this.password = null;\n        this._timeouts = [];\n        this._intervals = [];\n        resolve();\n      }).catch(reject);\n    });\n  }\n\n  setInterval(...params) {\n    const interval = setInterval(...params);\n    this._intervals.push(interval);\n    return interval;\n  }\n\n  setTimeout(...params) {\n    const restParams = params.slice(1);\n    const timeout = setTimeout(() => {\n      this._timeouts.splice(this._timeouts.indexOf(params[0]), 1);\n      params[0]();\n    }, ...restParams);\n    this._timeouts.push(timeout);\n    return timeout;\n  }\n\n  /**\n   * This shouldn\'t really be necessary to most developers as it is automatically invoked every 30 seconds, however\n   * if you wish to force a sync of Guild data, you can use this. Only applicable to user accounts.\n   * @param {Guild[]} [guilds=this.guilds.array()] An array of guilds to sync\n   */\n  syncGuilds(guilds = this.guilds.array()) {\n    if (!this.user.bot) {\n      this.ws.send({\n        op: 12,\n        d: guilds.map(g => g.id),\n      });\n    }\n  }\n\n  /**\n   * Caches a user, or obtains it from the cache if it\'s already cached.\n   * If the user isn\'t already cached, it will only be obtainable by OAuth bot accounts.\n   * @param {string} id The ID of the user to obtain\n   * @returns {Promise<User>}\n   */\n  fetchUser(id) {\n    if (this.users.has(id)) return Promise.resolve(this.users.get(id));\n    return this.rest.methods.getUser(id);\n  }\n\n  /**\n   * Returns a Collection, mapping Guild ID to Voice Connections.\n   * @readonly\n   * @type {Collection<string, VoiceConnection>}\n   */\n  get voiceConnections() {\n    return this.voice.connections;\n  }\n\n  /**\n   * The uptime for the logged in Client.\n   * @readonly\n   * @type {?number}\n   */\n  get uptime() {\n    return this.readyTime ? Date.now() - this.readyTime : null;\n  }\n}',
  ShardingManager: 'class ShardingManager extends EventEmitter {\n  /**\n   * Creates an instance of ShardingManager.\n   * @param {string} file the path to your file\n   * @param {number} totalShards the number of shards you would like to spawn\n   */\n  constructor(file, totalShards) {\n    super();\n    this.file = file;\n    if (!path.isAbsolute(file)) {\n      this.file = path.resolve(`${process.cwd()}${file}`);\n    }\n    /**\n     * The amount of shards that this manager is going to spawn\n     * @type {number}\n     */\n    this.totalShards = totalShards;\n    /**\n     * A collection of shards that this manager has spawned.\n     * @type {Collection<number, Shard>}\n     */\n    this.shards = new Collection();\n    this.waiting = new Collection();\n  }\n\n  createShard() {\n    const id = this.shards.size;\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    this.emit(\'launch\', id, shard);\n  }\n\n  spawn(amount) {\n    this.totalShards = amount;\n    this.createShard();\n    const interval = setInterval(() => {\n      if (this.shards.size === this.totalShards) {\n        return clearInterval(interval);\n      }\n      return this.createShard();\n    }, 5500);\n  }\n}' }